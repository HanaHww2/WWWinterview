# What I Learned  
* [인터페이스와 추상 클래스, 추상 메소드와 가상 메소드에 대하여](https://github.com/victoryAshe/WWWinterview/blob/main/Job_Interview/Ashe/C%23%EC%9D%98%20%EC%9D%B4%ED%95%B4/%EC%96%B8%EC%96%B4%EC%8A%A4%ED%8E%99.md#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B6%94%EC%83%81-%EB%A9%94%EC%86%8C%EB%93%9C%EC%99%80-%EA%B0%80%EC%83%81-%EB%A9%94%EC%86%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)
* [구조체와 클래스](https://github.com/victoryAshe/WWWinterview/blob/main/Job_Interview/Ashe/C%23%EC%9D%98%20%EC%9D%B4%ED%95%B4/%EC%96%B8%EC%96%B4%EC%8A%A4%ED%8E%99.md#%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4)
* [상속과 다형성]
---
## 인터페이스와 추상 클래스, 추상 메소드와 가상 메소드에 대하여
### 인터페이스 *Interface*
동일한 개념의 기능을 하는 클래스들을 묶은 개념으로, 구현 객체의 같은 동작을 보장하기 위해 사용된다.
* 특징
  * 기본적으로 public 접근지정자를 가지며, 다른 접근지정자를 설정할 수 없다.
  * 구체적인 구현을 기술할 수 없고, 클래스/프로퍼티 명만 지정할 수 있다.
  * 처리 속도 면에서 추상 클래스보다 느리다.
  * 필드를 가질 수 없으며, 함수는 추상 메소드만 가질 수 있다. 
  * 변수는 **static final**만 가질 수 있다.  
    ∵ 인터페이스의 변수는 스스로 초기화될 권한이 없다.   
  * new 연산자를 통한 인스턴스(객체) 생성이 불가능하나, 참조변수로 만들 수는 있다.
* 장점
  *  의도치 않은 속성/메소드 공개를 막을 수 있다.
  *  다중 상속에 따른 class의 표현을 여러가지로 가능하게 한다.
  *  외부 시스템에 제공할 서비스/객체 정보를 직접적인 class가 아닌 "선언"을 통해 제공한다.
  *  협업 시에 독립적인 프로그래밍이 가능하다.
  *  클래스 간의 결합도를 줄임으로써 유지보수성이 향상된다.

### 추상 클래스  *Abstract Class*
자식클래스(상속하는 클래스)에서 공유할 수 있도록 부모 클래스(추상 클래스)의 공통적인 정의를 제공하기 위해 사용된다.
* 특징
  * 모든 필드, 메소드들은 접근지정자를 지정하지 않을 시에 private이며 따로 접근지정자를 지정할 수 있다.
  * 추상/비추상 메소드와 프로퍼티, 필드, 상수 등을 가지며 구체적인 기능의 구현을 제공할 수 있다.
  * 처리 속도 면에서 인터페이스에 비해 빠르다.
  * 단일 상속만 허용한다. (다중상속 허용 X)
  * new 연산자를 통한 인스턴스(객체) 생성이 불가능하다.
* 장점
  * 실체 클래스들의 필드와 메소드를 통일하여, 실체 클래스 작성 시 시간을 절약할 수 있다.


### 추상 메소드  *Abstract Method*
메소드의 선언부만 있고 메소드 실행부```{}```가 없는 메소드. 항상 ```;``` 으로 끝난다.
* 특징
  * 실제 구현은 상속받은 실체 메소드에서 직접 작성한다.  
    : 자식 클래스는 추상메소드를 반드시 재정의하여 실행내용을 작성해야 한다. 
    -> 추상 클래스 설계 시, **자식 클래스가 반드시 실행해야 하는 메소드를 추상 메소드로 선언**한다.
  * 선언 시 ```static```/```virtual``` 등의 키워드는 사용할 수 없다.

### 가상 메소드  *Virtual Method*
가상 메소드를 정의한 클래스를 상속한 객체는 가상 메소드를 **선택적으로 재정의**할 수 있다.
상속받은 자식 객체가 가상 메소드를 재정의하지 않을 시, 부모의 가상 메소드를 그대로 사용한다.
* 특징
  * ```virtual``` 키워드가 붙는 것 외엔 일반 메소드와 동일하며, 추상 메소드와 달리 일반 클래스에서도 선언 가능하다.
    : 재정의가 필수는 아니며, 실제 기능의 구현부가 들어갈 수 있다. 
  * 상위 객체를 상속받은 자식 클래스에서 ```new``` / ```override```를 선택할 수 있다.
    * 자식 클래스의 함수 시그니쳐가 동일해야 재정의 가능
    * ```new```: 기본 클래스를 숨김 -> 상위 클래스 변수에 담기면 하위 클래스가 아닌 상위 클래스의 함수를 호출
    * ```override```: 상속받은 클래스를 재정의
  *  자식 클래스는 ```base``` 키워드를 이용해 부모 클래스의 함수 호출 가능
  *  ```static``` / ```abstract``` / ```private``` / ```override``` 키워드들과는 사용 불가능  
  
---
## 구조체와 클래스  `
### 구조체  


### 클래스  
  

---
## 상속과 다형성
### 상속


### 다형성



---
